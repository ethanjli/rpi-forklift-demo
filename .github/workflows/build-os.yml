name: build-os
on:
  workflow_call:
    inputs:
      name:
        description: 'The name of the OS image to build'
        required: true
        type: string
      base_release_name:
        description: 'The release name of the RPi OS base image (bullseye, bookworm)'
        required: true
        type: string
      base_image_variant:
        description: 'The name of the RPi OS base image variant (lite, desktop, or full)'
        required: true
        type: string
      base_release_date:
        description: 'The release date of the RPi OS base image'
        required: true
        type: string
      arch:
        description: 'The CPU architecture of the OS (armhf, arm64)'
        required: true
        type: string

jobs:
  build:
    name: Build image
    runs-on: ubuntu-latest
    env:
      OUTPUT_IMAGE_NAME: ${{ inputs.name }}-${{ inputs.base_release_name }}-${{ inputs.arch }}-${{ inputs.base_image_variant }}
      SETUP_USER: pi
    permissions:
      contents: read
      packages: write
      id-token: write
    steps:
      # Checkout push-to-registry action GitHub repository
      - name: Checkout Push to Registry action
        uses: actions/checkout@v4

      # TODO: build and publish arm64 vm kernels for QEMU `virt` machines in a separate repo
      # (see https://lca-kernel.ozlabs.org/2022-Currey-Abusing-GitHub-Actions-for-building-and-testing-kernels.pdf)
      # Trigger it with a workflow dispatch, providing the kernel version to build. Uploaded
      # artifacts (and uploads for release) should include .config, logs, and the kernel image.
      - name: Build or use arm64 VM kernel
        id: vm-kernel
        env:
          KERNEL_VERSION: 6.6.32
        run: |
          cached_kernel=".cache/vm-kernels/kernel-linux-virt-arm64-${{ env.KERNEL_VERSION }}.img"
          if [ -f "$cached_kernel" ]; then
            echo "Using cached image kernel at $cached_kernel..."
          else
            # From https://gist.github.com/cGandom/23764ad5517c8ec1d7cd904b923ad863
            echo "Compiling kernel ${{ env.KERNEL_VERSION }} to $cached_kernel..."
            sudo apt-get install gcc-aarch64-linux-gnu g++-aarch64-linux-gnu
            kernel_dir="linux-${{ env.KERNEL_VERSION }}"
            echo "https://cdn.kernel.org/pub/linux/kernel/v6.x/$kernel_dir.tar.xz"
            curl -s -L "https://cdn.kernel.org/pub/linux/kernel/v6.x/$kernel_dir.tar.xz" | \
              tar -xJf -
            export ARCH=arm64
            export CROSS_COMPILE=/bin/aarch64-linux-gnu-
            make -C "$kernel_dir" defconfig # make a .config file
            make -C "$kernel_dir" nopm.config
            make -C "$kernel_dir" virt.config
            make -C "$kernel_dir" kvm_guest.config
            sed -i \
              -e 's~^CONFIG_ACPI=.*~# CONFIG_ACPI is not set~g' \
              -e 's~^CONFIG_ACPI_\(.*\)=.*~# CONFIG_ACPI_\1 is not set~g' \
              -e 's~^CONFIG_BPF=.*~# CONFIG_BPF is not set~g' \
              -e 's~^CONFIG_BT=.*~# CONFIG_BT is not set~g' \
              -e 's~^CONFIG_WIRELESS=.*~# CONFIG_WIRELESS is not set~g' \
              -e 's~^CONFIG_HAVE_PCI=.*~# CONFIG_HAVE_PCI is not set~g' \
              -e 's~^CONFIG_PCI=.*~# CONFIG_PCI is not set~g' \
              -e 's~^CONFIG_PCI_\(.*\)=.*~# CONFIG_PCI_\1 is not set~g' \
              -e 's~^CONFIG_NVME_CORE=.*~# CONFIG_NVME_CORE is not set~g' \
              -e 's~^CONFIG_\(.*\)_NVME=.*~# CONFIG_\1_NVME is not set~g' \
              -e 's~^CONFIG_ETHERNET=.*~# CONFIG_ETHERNET is not set~g' \
              -e 's~^CONFIG_PHYLINK=.*~# CONFIG_PHYLINK is not set~g' \
              -e 's~^CONFIG_PHYLIB=.*~# CONFIG_PHYLIB is not set~g' \
              -e 's~^CONFIG_SWPHY=.*~# CONFIG_SWPHY is not set~g' \
              -e 's~^CONFIG_FIXED_PHY=.*~# CONFIG_FIXED_PHY is not set~g' \
              -e 's~^CONFIG_USB_NET_DRIVERS=.*~# CONFIG_USB_NET_DRIVERS is not set~g' \
              -e 's~^CONFIG_WLAN=.*~# CONFIG_WLAN is not set~g' \
              -e 's~^CONFIG_INPUT=.*~# CONFIG_INPUT is not set~g' \
              -e 's~^CONFIG_INPUT_\(.*\)=.*~# CONFIG_INPUT_\1 is not set~g' \
              -e 's~^CONFIG_MOUSE_\(.*\)=.*~# CONFIG_MOUSE_\1 set~g' \
              -e 's~^CONFIG_MEDIA_\(.*\)=.*~# CONFIG_MEDIA_\1 is not set~g' \
              -e 's~^CONFIG_MEDIA_SUPPORT=.*~# CONFIG_MEDIA_SUPPORT is not set~g' \
              -e 's~^CONFIG_THERMAL=.*~# CONFIG_THERMAL is not set~g' \
              -e 's~^CONFIG_THERMAL_\(.*\)=.*~# CONFIG_THERMAL_\1 is not set~g' \
              -e 's~^CONFIG_DRM=.*~# CONFIG_DRM is not set~g' \
              -e 's~^CONFIG_DRM_\(.*\)=.*~# CONFIG_DRM_\1 is not set~g' \
              -e 's~^CONFIG_FB=.*~# CONFIG_FB is not set~g' \
              -e 's~^CONFIG_SOUND=.*~# CONFIG_SOUND is not set~g' \
              -e 's~^CONFIG_SND=.*~# CONFIG_SND is not set~g' \
              -e 's~^CONFIG_SND_PCI=.*~# CONFIG_SND_PCI is not set~g' \
              -e 's~^CONFIG_SND_USB=.*~# CONFIG_SND_USB is not set~g' \
              -e 's~^CONFIG_HID=.*~# CONFIG_HID is not set~g' \
              -e 's~^CONFIG_HID_\(.*\)=.*~# CONFIG_HID_\1 is not set~g' \
              -e 's~^CONFIG_BTRFS_FS=.*~# CONFIG_BTRFS_FS is not set~g' \
              -e 's~^CONFIG_MISC_FILESYSTEMS=.*~# CONFIG_MISC_FILESYSTEMS is not set~g' \
              -e 's~^CONFIG_NETWORK_FILESYSTEMS=.*~# CONFIG_NETWORK_FILESYSTEMS is not set~g' \
              -e 's~^CONFIG_NFS_FS=.*~# CONFIG_NFS_FS is not set~g' \
              -e 's~^CONFIG_NFS_\(.*\)=.*~# CONFIG_NFS_\1 is not set~g' \
              "$kernel_dir/.config"
            make -C "$kernel_dir" -j8 # build the kernel
            mkdir -p .cache/vm-kernels/
            cp "$kernel_dir/arch/arm64/boot/Image" "$cached_kernel"
          fi
          echo "kernel_image=$cached_kernel" >> $GITHUB_OUTPUT

      - name: Determine Raspberry Pi OS base image URL
        id: rpi-os-image
        run: |
          case '${{ inputs.base_release_name }}' in
            'bookworm')
              IMAGE_RELEASE_CHANNEL='raspios'
              ;;
            'bullseye')
              IMAGE_RELEASE_CHANNEL='raspios_oldstable'
              ;;
            *)
              echo "Unknown release name: ${{ inputs.base_release_name }}"
              exit 1
              ;;
          esac
          IMAGE_REPO_GROUP="$IMAGE_RELEASE_CHANNEL"
          if [[ "${{ inputs.base_image_variant }}" != "desktop" ]]; then
            IMAGE_REPO_GROUP="${IMAGE_REPO_GROUP}_${{ inputs.base_image_variant }}"
          fi
          IMAGE_REPO_GROUP="${IMAGE_REPO_GROUP}_${{ inputs.arch }}"
          IMAGE_FILENAME="${{ inputs.base_release_date }}-raspios-${{ inputs.base_release_name }}-${{ inputs.arch }}"
          if [[ "${{ inputs.base_image_variant }}" != "desktop" ]]; then
            IMAGE_FILENAME="${IMAGE_FILENAME}-${{ inputs.base_image_variant }}"
          fi
          IMAGE_FILENAME="${IMAGE_FILENAME}.img.xz"
          IMAGE_URL="https://downloads.raspberrypi.com/$IMAGE_REPO_GROUP/images/$IMAGE_REPO_GROUP-${{ inputs.base_release_date }}/$IMAGE_FILENAME"
          echo "RPi OS image filename: $IMAGE_FILENAME"
          echo "image_filename=$IMAGE_FILENAME" >> $GITHUB_OUTPUT
          echo "RPi OS image URL: $IMAGE_URL"
          echo "image_url=$IMAGE_URL" >> $GITHUB_OUTPUT

      - name: Set up base image caching
        uses: actions/cache@v4
        with:
          key: base-image-${{ steps.rpi-os-image.outputs.image_url }}
          path: .cache/base-images/${{ steps.rpi-os-image.outputs.image_filename }}

      # TODO: split this off into a GitHub Action, with a parameterized cache path and better
      # handling of different archive formats
      - name: Download & decompress base image
        id: download-base
        run: |
          cached_download=".cache/base-images/${{ steps.rpi-os-image.outputs.image_filename }}"
          if [ -f "$cached_download" ]; then
          echo "Using cached image download at $cached_download..."
          else
            echo "Downloading ${{ steps.rpi-os-image.outputs.image_url }} to $cached_download..."
            curl -o "$cached_download" "${{ steps.rpi-os-image.outputs.image_url }}"
          fi

          tmpfile="$(mktemp -u)"
          mime="$(file -b --mime-type "$cached_download")"
          case "$mime" in
            application/octet-stream)
              echo "Copying $cached_download to $tmpfile..."
              cp "$cached_download" "$tmpfile"
              ;;
            application/gzip | application/x-gzip)
              echo "Extracting $cached_download to $tmpfile..."
              gunzip -c "$cached_download" > "$tmpfile"
              ;;
            application/x-xz)
              echo "Extracting $cached_download to $tmpfile..."
              unxz -c "$cached_download" > "$tmpfile"
              ;;
            *)
              echo -e "\033[0;31m### Error: Unknown image mimetype: $mime\033[0m"
              return 1
              ;;
          esac
          echo "mountable_image=$tmpfile" >> $GITHUB_OUTPUT

      # TODO: split this off into a piresize action
      - name: Expand & mount base image
        id: mount-base
        run: |
          image="${{ steps.download-base.outputs.mountable_image }}"
          truncate -s 8G $image
          echo ", +" | sfdisk -N 2 $image
          device="$(sudo losetup -fP --show $image)"
          sudo e2fsck -p -f "${device}p2"
          sudo resize2fs "${device}p2"
          echo "Mounting $device to /mnt/img-build..."
          sudo mkdir -p /mnt/img-build
          sudo mount "${device}p2" /mnt/img-build
          sudo mount "${device}p1" /mnt/img-build/boot
          sudo ./tools/unmount-image.sh "$device" "$sysroot"

      - name: Prepare for running OS build scripts
        run: |
          sudo apt-get install systemd-container qemu-user-static binfmt-support qemu-system-aarch64

      # Note: for performance reasons, we run most setup steps in a systemd-nspawn container. We
      # could boot it if we wanted (and it works fine for setup on a -lite base image), but for
      # some reason setup doesn't work on a -desktop base image (systemd calls during setup all fail
      # with a "Transport endpoint is not connected" error)
      - name: Run OS build scripts in an unbooted container
        run: |
          image="${{ steps.download-base.outputs.mountable_image }}"
          sysroot="/mnt/img-build"
          device="$(sudo ./tools/mount-image.sh "$image" "$sysroot")"
          echo "Booting a systemd-nspawn container for most of the setup..."
          sudo systemd-nspawn --directory $sysroot \
            --bind "$(pwd)"/os-setup:/run/os-setup \
            su - ${{ env.SETUP_USER }} /run/os-setup/setup/setup-unbooted.sh
          sudo ./tools/unmount-image.sh "$device" "$sysroot"

      - name: Prepare to run remaining OS build scripts in a booted VM
        id: prepare-vm
        run: |
          image="${{ steps.download-base.outputs.mountable_image }}"
          sysroot="/mnt/img-build"
          device="$(sudo ./tools/mount-image.sh "$image" "$sysroot")"
          sudo systemd-nspawn --directory $sysroot \
            --bind "$(pwd)"/os-setup:/run/os-setup \
            /run/os-setup/ci-pre-vm-boot.sh ${{ env.SETUP_USER }}
          sudo ./tools/unmount-image.sh "$device" "$sysroot"

      - name: Set up arm64 VM kernel caching
        uses: actions/cache@v4
        env:
          KERNEL_VERSION: 6.6.32
        with:
          key: kernel-linux-virt-arm64-${{ env.KERNEL_VERSION }}
          path: .cache/vm-kernels/kernel-linux-virt-arm64-${{ env.KERNEL_VERSION }}.img

      # Note: we need to boot the OS in a VM rather than a systemd-nspawn container because
      # `docker.service` can't start properly in the container due to its interaction with
      # the kernel (in bullseye Docker's use of iptables/nftables results in error
      # "Failed to initialize nft: Protocol not supported"; in bookworm Docker's use of cgroups
      # results in error "failed to start daemon: Devices cgroup isn't mounted").
      - name: Run OS build scripts in a booted VM
        env:
          # We use the `virt` hardware type because the `raspi3b` hardware type doesn't work with
          # bookworm, and because the `raspi4b` hardware type is only available in QEMU 9 (which
          # isn't available in ubuntu-24.04 but can be installed in an Arch Linux container,
          # e.g. with addnab/docker-run-action@v3) and doesn't seem to support the `usb-net` network
          # device type, and definitely doesn't support PCI or Ethernet.
          MACHINE: 'virt'
          CPU: max
          RAM: 4G
          FS_IMAGE: ${{ steps.download-base.outputs.mountable_image }}
        run: |
          # From https://gist.github.com/cGandom/23764ad5517c8ec1d7cd904b923ad863
          qemu-system-aarch64 \
            -machine ${{ env.MACHINE }} -cpu ${{ env.CPU }} -nographic \
            -smp 4 -m ${{ env.RAM }} \
            -kernel ${{ steps.vm-kernel.outputs.kernel_image }} \
            -drive file=${{ env.FS_IMAGE }},if=none,id=hd0,format=raw,cache=writeback \
            -device virtio-blk,drive=hd0,bootindex=0 \
            -netdev user,id=net0,hostfwd=tcp::2222-:22 \
            -device virtio-net-pci,netdev=net0 \
            -monitor telnet:127.0.0.1:5555,server,nowait \
            -append "root=/dev/vda2"

      - name: Clean up after VM boot
        run: |
          image="${{ steps.download-base.outputs.mountable_image }}"
          sysroot="/mnt/img-build"
          device="$(sudo ./tools/mount-image.sh "$image" "$sysroot")"
          sudo systemd-nspawn --directory $sysroot \
            --bind "$(pwd)"/os-setup:/run/os-setup \
            /run/os-setup/ci-post-vm-boot.sh ${{ env.SETUP_USER }}
          sudo systemd-nspawn --directory $sysroot \
            --bind "$(pwd)"/os-setup:/run/os-setup \
            /run/os-setup/ci-pre-headless-boot.sh
          sudo ./tools/unmount-image.sh "$device" "$sysroot"

      # TODO: split this off into a piresize action
      - name: Run pishrink
        run: |
          wget https://raw.githubusercontent.com/Drewsif/PiShrink/master/pishrink.sh
          chmod a+x pishrink.sh
          sudo ./pishrink.sh -za \
            ${{ steps.download-base.outputs.mountable_image }} \
            ${{ env.OUTPUT_IMAGE_NAME }}.img

      - name: Upload image to Job Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.OUTPUT_IMAGE_NAME }}
          path: ${{ env.OUTPUT_IMAGE_NAME }}.img.gz
          if-no-files-found: error
          retention-days: 0
          compression-level: 0
          overwrite: true
