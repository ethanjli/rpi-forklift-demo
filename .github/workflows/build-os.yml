name: build-os
on:
  workflow_call:
    inputs:
      name:
        description: 'The name of the OS image to build'
        required: true
        type: string
      base_release_name:
        description: 'The release name of the RPi OS base image (bullseye, bookworm)'
        required: true
        type: string
      base_image_variant:
        description: 'The name of the RPi OS base image variant (lite, desktop, or full)'
        required: true
        type: string
      base_release_date:
        description: 'The release date of the RPi OS base image'
        required: true
        type: string
      arch:
        description: 'The CPU architecture of the OS (armhf, arm64)'
        required: true
        type: string

jobs:
  build:
    name: Build image
    runs-on: ubuntu-latest
    env:
      OUTPUT_IMAGE_NAME: ${{ inputs.name }}-${{ inputs.base_release_name }}-${{ inputs.arch }}-${{ inputs.base_image_variant }}
    permissions:
      contents: read
      packages: write
      id-token: write
    steps:
      # Checkout push-to-registry action GitHub repository
      - name: Checkout Push to Registry action
        uses: actions/checkout@v4

      - name: Determine Raspberry Pi OS base image URL
        run: |
          case '${{ inputs.base_release_name }}' in
            'bookworm')
              BASE_IMAGE_RELEASE_CHANNEL='raspios'
              ;;
            'bullseye')
              BASE_IMAGE_RELEASE_CHANNEL='raspios_oldstable'
              ;;
            *)
              echo "Unknown release name: ${{ inputs.base_release_name }}"
              exit 1
              ;;
          esac
          BASE_IMAGE_REPO_GROUP="$BASE_IMAGE_RELEASE_CHANNEL"
          if [[ "${{ inputs.base_image_variant }}" != "desktop" ]]; then
            BASE_IMAGE_REPO_GROUP="${BASE_IMAGE_REPO_GROUP}_${{ inputs.base_image_variant }}"
          fi
          BASE_IMAGE_REPO_GROUP="${BASE_IMAGE_REPO_GROUP}_${{ inputs.arch }}"
          BASE_IMAGE_FILENAME="${{ inputs.base_release_date }}-raspios-${{ inputs.base_release_name }}-${{ inputs.arch }}"
          if [[ "${{ inputs.base_image_variant }}" != "desktop" ]]; then
            BASE_IMAGE_FILENAME="${BASE_IMAGE_FILENAME}-${{ inputs.base_image_variant }}"
          fi
          BASE_IMAGE_FILENAME="${BASE_IMAGE_FILENAME}.img.xz"
          BASE_IMAGE_URL="https://downloads.raspberrypi.com/$BASE_IMAGE_REPO_GROUP/images/$BASE_IMAGE_REPO_GROUP-${{ inputs.base_release_date }}/$BASE_IMAGE_FILENAME"
          echo "BASE_IMAGE_FILENAME=$BASE_IMAGE_FILENAME" >> $GITHUB_ENV
          echo "BASE_IMAGE_URL=$BASE_IMAGE_URL" >> $GITHUB_ENV

      - name: Prepare for base image caching
        run: mkdir -p .cache/base-images

      - name: Set up base image caching
        uses: actions/cache@v4
        with:
          key: base-image-${{ env.BASE_IMAGE_URL }}
          path: .cache/base-images/${{ env.BASE_IMAGE_FILENAME }}

      - name: Download & decompress base image
        id: download-base
        run: |
          cached_download=".cache/base-images/${{ env.BASE_IMAGE_FILENAME }}"
          if [ -f "$cached_download" ]; then
          echo "Using cached image download at $cached_download..."
          else
            echo "Downloading ${{ env.BASE_IMAGE_URL }} to $cached_download..."
            curl -o "$cached_download" "${{ env.BASE_IMAGE_URL }}"
          fi

          tmpfile="$(mktemp -u)"
          mime="$(file -b --mime-type "$cached_download")"
          case "$mime" in
            application/octet-stream)
              echo "Copying $cached_download to $tmpfile..."
              cp "$cached_download" "$tmpfile"
              ;;
            application/gzip | application/x-gzip)
              echo "Extracting $cached_download to $tmpfile..."
              gunzip -c "$cached_download" > "$tmpfile"
              ;;
            application/x-xz)
              echo "Extracting $cached_download to $tmpfile..."
              unxz -c "$cached_download" > "$tmpfile"
              ;;
            *)
              echo -e "\033[0;31m### Error: Unknown image mimetype: $mime\033[0m"
              return 1
              ;;
          esac
          echo "mountable_image=$tmpfile" >> "$GITHUB_OUTPUT"

      - name: Expand & mount base image
        id: mount-base
        run: |
          truncate -s 8G ${{ steps.download-base.outputs.mountable_image }}
          echo ", +" | sfdisk -N 2 ${{ steps.download-base.outputs.mountable_image }}
          device="$(sudo losetup -fP --show ${{ steps.download-base.outputs.mountable_image }})"
          e2fsck -p -f "${device}p2"
          resize2fs "${device}p2"
          echo "Mounting $device to /mnt/build..."
          sudo mkdir -p /mnt/build
          sudo mount "${device}p2" /mnt/build
          sudo mount "${device}p1" /mnt/build/boot
          echo "sysroot=/mnt/build" >> "$GITHUB_OUTPUT"
          echo "device=$device" >> "$GITHUB_OUTPUT"

      - name: Run OS build scripts
        run: |
          sudo apt-get install systemd-container qemu-user-static binfmt-support
          sudo systemd-nspawn \
            --directory=${{ steps.mount-base.outputs.sysroot }} \
            --bind=os-setup:/run/os-setup
            /run/os-setup/ci-entrypoint.sh
            # --boot

      - name: Unmount base image
        run: |
          sudo umount ${{ steps.mount-base.outputs.sysroot }}
          sudo losetup -d ${{ steps.mount-base.outputs.device }}
          mv ${{ steps.download-base.outputs.mountable_image }}

      - name: Run pishrink
        run: |
          wget https://raw.githubusercontent.com/Drewsif/PiShrink/master/pishrink.sh
          chmod a+x pishrink.sh
          sudo ./pishrink.sh -za \
            ${{ steps.download-base.outputs.mountable_image }} \
            ${{ env.OUTPUT_IMAGE_NAME }}.img

      - name: Upload image to Job Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.OUTPUT_IMAGE_NAME }}
          path: ${{ env.OUTPUT_IMAGE_NAME }}.img.gz
          if-no-files-found: error
          retention-days: 0
          compression-level: 0
          overwrite: true
