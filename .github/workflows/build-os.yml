name: build-os
on:
  workflow_call:
    inputs:
      name:
        description: 'The name of the OS image to build'
        required: true
        type: string
      base_release_name:
        description: 'The release name of the RPi OS base image (bullseye, bookworm)'
        required: true
        type: string
      base_image_variant:
        description: 'The name of the RPi OS base image variant (lite, desktop, or full)'
        required: true
        type: string
      base_release_date:
        description: 'The release date of the RPi OS base image'
        required: true
        type: string
      arch:
        description: 'The CPU architecture of the OS (armhf, arm64)'
        required: true
        type: string

jobs:
  build:
    name: Build image
    runs-on: ubuntu-latest
    env:
      OUTPUT_IMAGE_NAME: ${{ inputs.name }}-${{ inputs.base_release_name }}-${{ inputs.arch }}-${{ inputs.base_image_variant }}
      KERNEL_VERSION: 6.1.21
      SETUP_USER: pi
    permissions:
      contents: read
      packages: write
      id-token: write
    steps:
      # Checkout push-to-registry action GitHub repository
      - name: Checkout Push to Registry action
        uses: actions/checkout@v4

      - name: Determine Raspberry Pi OS base image URL
        id: rpi-os-image
        run: |
          case '${{ inputs.base_release_name }}' in
            'bookworm')
              IMAGE_RELEASE_CHANNEL='raspios'
              ;;
            'bullseye')
              IMAGE_RELEASE_CHANNEL='raspios_oldstable'
              ;;
            *)
              echo "Unknown release name: ${{ inputs.base_release_name }}"
              exit 1
              ;;
          esac
          IMAGE_REPO_GROUP="$IMAGE_RELEASE_CHANNEL"
          if [[ "${{ inputs.base_image_variant }}" != "desktop" ]]; then
            IMAGE_REPO_GROUP="${IMAGE_REPO_GROUP}_${{ inputs.base_image_variant }}"
          fi
          IMAGE_REPO_GROUP="${IMAGE_REPO_GROUP}_${{ inputs.arch }}"
          IMAGE_FILENAME="${{ inputs.base_release_date }}-raspios-${{ inputs.base_release_name }}-${{ inputs.arch }}"
          if [[ "${{ inputs.base_image_variant }}" != "desktop" ]]; then
            IMAGE_FILENAME="${IMAGE_FILENAME}-${{ inputs.base_image_variant }}"
          fi
          IMAGE_FILENAME="${IMAGE_FILENAME}.img.xz"
          IMAGE_URL="https://downloads.raspberrypi.com/$IMAGE_REPO_GROUP/images/$IMAGE_REPO_GROUP-${{ inputs.base_release_date }}/$IMAGE_FILENAME"
          echo "RPi OS image filename: $IMAGE_FILENAME"
          echo "image_filename=$IMAGE_FILENAME" >> $GITHUB_OUTPUT
          echo "RPi OS image URL: $IMAGE_URL"
          echo "image_url=$IMAGE_URL" >> $GITHUB_OUTPUT

      - name: Set up base image caching
        uses: actions/cache@v4
        with:
          key: base-image-${{ steps.rpi-os-image.outputs.image_url }}
          path: .cache/base-images/${{ steps.rpi-os-image.outputs.image_filename }}

      # TODO: split this off into a GitHub Action, with a parameterized cache path and better
      # handling of different archive formats
      - name: Download & decompress base image
        id: download-base
        run: |
          cached_download=".cache/base-images/${{ steps.rpi-os-image.outputs.image_filename }}"
          if [ -f "$cached_download" ]; then
          echo "Using cached image download at $cached_download..."
          else
            echo "Downloading ${{ steps.rpi-os-image.outputs.image_url }} to $cached_download..."
            curl -o "$cached_download" "${{ steps.rpi-os-image.outputs.image_url }}"
          fi

          tmpfile="$(mktemp -u)"
          mime="$(file -b --mime-type "$cached_download")"
          case "$mime" in
            application/octet-stream)
              echo "Copying $cached_download to $tmpfile..."
              cp "$cached_download" "$tmpfile"
              ;;
            application/gzip | application/x-gzip)
              echo "Extracting $cached_download to $tmpfile..."
              gunzip -c "$cached_download" > "$tmpfile"
              ;;
            application/x-xz)
              echo "Extracting $cached_download to $tmpfile..."
              unxz -c "$cached_download" > "$tmpfile"
              ;;
            *)
              echo -e "\033[0;31m### Error: Unknown image mimetype: $mime\033[0m"
              return 1
              ;;
          esac
          echo "mountable_image=$tmpfile" >> $GITHUB_OUTPUT

      # TODO: split this off into a piresize action
      - name: Expand & mount base image
        run: |
          image="${{ steps.download-base.outputs.mountable_image }}"
          truncate -s 8G $image
          echo ", +" | sfdisk -N 2 $image
          device="$(sudo losetup -fP --show $image)"
          sudo e2fsck -p -f "${device}p2"
          sudo resize2fs "${device}p2"
          echo "Mounting $device to /mnt/img-build..."
          sudo mkdir -p /mnt/img-build
          sudo mount "${device}p2" /mnt/img-build
          sudo mount "${device}p1" /mnt/img-build/boot
          echo "IMAGE_SYSROOT=/mnt/img-build" >> $GITHUB_ENV
          echo "IMAGE_DEVICE=$device" >> $GITHUB_ENV

      - name: Prepare for running OS build scripts
        run: |
          sudo apt-get install systemd-container qemu-user-static binfmt-support

      # Note: for performance reasons, we run most setup steps in a systemd-nspawn container. We
      # could boot it if we wanted (and it works fine for setup on a -lite base image), but for
      # some reason setup doesn't work on a -desktop base image (systemd calls during setup all fail
      # with a "Transport endpoint is not connected" error)
      - name: Run OS build scripts in an unbooted container
        run: |
          sysroot=${{ env.IMAGE_SYSROOT }}
          echo "Booting a systemd-nspawn container for most of the setup..."
          sudo systemd-nspawn --directory $sysroot \
            --bind "$(pwd)"/os-setup:/run/os-setup \
            su - ${{ env.SETUP_USER }} /run/os-setup/setup/setup-unbooted.sh

      - name: Prepare to run remaining OS build scripts in a booted VM
        run: |
          image="${{ steps.download-base.outputs.mountable_image }}"
          sysroot=${{ env.IMAGE_SYSROOT }}
          sudo systemd-nspawn --directory $sysroot \
            --bind "$(pwd)"/os-setup:/run/os-setup \
            /run/os-setup/ci-pre-vm-boot.sh ${{ env.SETUP_USER }}
          sudo cp -r $sysroot/boot /run/vm-boot
          sudo ./tools/unmount-image.sh ${{ env.IMAGE_DEVICE }} "$sysroot"

      # Note: we need to boot the OS in a VM rather than a systemd-nspawn container because
      # `docker.service` can't start properly in the container due to its interaction with
      # the kernel and with systemd-nspawn (in bullseye Docker's use of iptables/nftables results in
      # error "Failed to initialize nft: Protocol not supported"; in bookworm Docker's use of
      # cgroups results in error "failed to start daemon: Devices cgroup isn't mounted", probably
      # because systemd-nspawn makes cgroups read-only while Docker needs to manipulate cgroups).
      - name: Run OS build scripts in a booted VM
        # Note: the `raspi3b` hardware type doesn't work with bookworm. The `raspi4b` hardware
        # type is only available in QEMU 9 (which isn't available in ubuntu-24.04 but can be
        # installed in an Arch Linux container, e.g. with addnab/docker-run-action@v3) and doesn't
        # seem to support the `usb-net` network device type, and definitely doesn't support PCI or
        # Ethernet.
        uses: addnab/docker-run-action@v3
        with:
          image: archlinux:base
          options:
            -v ${{ steps.download-base.outputs.mountable_image }}:/run/vm-sd-image.img
            -v /run/vm-boot:/run/vm-boot
            --device=/dev/kvm:/dev/kvm --device=/dev/net/tun:/dev/net/tun --cap-add NET_ADMIN
          run: |
            pacman -Sy
            yes | pacman -S qemu-system-aarch64 qemu-user-static qemu-user-static-binfmt
            qemu-system-aarch64 \
              -machine raspi3b -dtb /run/vm-boot/bcm2710-rpi-3-b-plus.dtb \
              -cpu cortex-a72 -smp 4 -m 1G \
              -kernel /run/vm-boot/kernel8.img \
              -drive file=/run/vm-sd-image.img,if=sd,format=raw,index=0,media=disk \
              -netdev user,id=net0,hostfwd=tcp::2222-:22 -device usb-net,netdev=net0 \
              -append "rw earlyprintk loglevel=8 console=ttyAMA0,115200 dwc_otg.lpm_enable=0 root=/dev/mmcblk0p2 rootdelay=1" \
              -nographic

      - name: Clean up after VM boot
        run: |
          image="${{ steps.download-base.outputs.mountable_image }}"
          sysroot=${{ env.IMAGE_SYSROOT }}
          device="$(sudo ./tools/mount-image.sh "$image" "$sysroot")"
          sudo systemd-nspawn --directory $sysroot \
            --bind "$(pwd)"/os-setup:/run/os-setup \
            /run/os-setup/ci-post-vm-boot.sh ${{ env.SETUP_USER }}
          sudo systemd-nspawn --directory $sysroot \
            --bind "$(pwd)"/os-setup:/run/os-setup \
            /run/os-setup/ci-pre-headless-boot.sh
          sudo ./tools/unmount-image.sh "$device" "$sysroot"

      # TODO: split this off into a piresize action
      - name: Run pishrink
        run: |
          wget https://raw.githubusercontent.com/Drewsif/PiShrink/master/pishrink.sh
          chmod a+x pishrink.sh
          sudo ./pishrink.sh -za \
            ${{ steps.download-base.outputs.mountable_image }} \
            ${{ env.OUTPUT_IMAGE_NAME }}.img

      - name: Upload image to Job Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.OUTPUT_IMAGE_NAME }}
          path: ${{ env.OUTPUT_IMAGE_NAME }}.img.gz
          if-no-files-found: error
          retention-days: 0
          compression-level: 0
          overwrite: true
